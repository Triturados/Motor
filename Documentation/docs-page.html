<!DOCTYPE html>
<html lang="en"> 
<head>
    <title>LoveEngine - Documentación</title>
    
    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="description" content="Bootstrap 4 Template For Software Startups">
    <meta name="author" content="Xiaoying Riley at 3rd Wave Media">    
    <link rel="shortcut icon" href="favicon.ico"> 
    
    <!-- Google Font -->
    <link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap" rel="stylesheet">
    
    <!-- FontAwesome JS-->
    <script defer src="assets/fontawesome/js/all.min.js"></script>
    
    <!-- Plugins CSS -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.2/styles/atom-one-dark.min.css">
    <link rel="stylesheet" href="assets/plugins/simplelightbox/simple-lightbox.min.css">

    <!-- Theme CSS -->  
    <link id="theme-style" rel="stylesheet" href="assets/css/theme.css">

</head> 

<body class="docs-page">    
    <header class="header fixed-top">	    
        <div class="branding docs-branding">
            <div class="container-fluid position-relative py-2">
                <div class="docs-logo-wrapper">
					<button id="docs-sidebar-toggler" class="docs-sidebar-toggler docs-sidebar-visible me-2 d-xl-none" type="button">
	                    <span></span>
	                    <span></span>
	                    <span></span>
	                </button>
	                <div class="site-logo"><a class="navbar-brand" href="index.html"><img class="logo-icon me-2" src="assets/images/coderdocs-logo.svg" alt="logo"><span class="logo-text">LOVE <span class="text-alt">Engine</span></span></a></div>    
                </div><!--//docs-logo-wrapper-->
	            <div class="docs-top-utilities d-flex justify-content-end align-items-center">
	                <div class="top-search-box d-none d-lg-flex">
		                <form class="search-form">
				            <input type="text" placeholder="Buscar en la documentación... " name="search" class="form-control search-input">
				            <button type="submit" class="btn search-btn" value="Search"><i class="fas fa-search"></i></button>
				        </form>
	                </div>
	
					<ul class="social-list list-inline mx-md-3 mx-lg-5 mb-0 d-none d-lg-flex">
						<li class="list-inline-item"><a href="https://github.com/Triturados/Motor"><i class="fab fa-github fa-fw"></i></a></li>
		            </ul><!--//social-list-->
		            <a href="https://www.youtube.com/watch?v=mCdA4bJAGGk" class="btn btn-primary d-none d-lg-flex">Descargar</a>
	            </div><!--//docs-top-utilities-->
            </div><!--//container-->
        </div><!--//branding-->
    </header><!--//header-->
    
    
    <div class="docs-wrapper">
	    <div id="docs-sidebar" class="docs-sidebar">
		    <div class="top-search-box d-lg-none p-3">
                <form class="search-form">
		            <input type="text" placeholder="Search the docs..." name="search" class="form-control search-input">
		            <button type="submit" class="btn search-btn" value="Search"><i class="fas fa-search"></i></button>
		        </form>
            </div>
		    <nav id="docs-nav" class="docs-nav navbar">
			    <ul class="section-items list-unstyled nav flex-column pb-3">
				    <li class="nav-item section-title"><a class="nav-link scrollto active" href="#section-1"><span class="theme-icon-holder me-2"><i class="fas fa-map-signs"></i></span>Introdución</a></li>
				    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-2"><span class="theme-icon-holder me-2"><i class="fas fa-arrow-down"></i></span>Instalación</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-create"><span class="theme-icon-holder me-2"><i class="fas fa-laptop-code"></i></span>Crea tu propio componente</a></li>
				    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-createscene"><span class="theme-icon-holder me-2"><i class="fas fa-laptop-code"></i></span>Crea tu propia escena</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-3-1-1">Forma de tabla</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-3-1-2">Forma funcional</a></li>
				    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-3"><span class="theme-icon-holder me-2"><i class="fas fa-box"></i></span>ECS</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-3-1">Escenas</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-3-2">Componentes</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-3-33">GameObjects</a></li>
				    <li class="nav-item section-title mt-3"><a class="card-link-mask" href="docs-pagecomponent.html"><span class="theme-icon-holder me-2"><i class="fas fa-cogs"></i></span>LOVE Components</a></li>
				    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-5"><span class="theme-icon-holder me-2"><i class="fas fa-tools"></i></span>LUA</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-5-1">Scene</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-5-2">GameObject</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-5-3">Component</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-5-4">Window</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-5-5">Blueprints</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-5-6">General</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-5-7">Global variable</a></li>
				    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-6"><span class="theme-icon-holder me-2"><i class="fas fa-laptop-code"></i></span>SceneManager</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-6-1">Formas de cambiar escenas</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-6-2">Funciones</a></li>
				    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-7"><span class="theme-icon-holder me-2"><i class="fas fa-tablet-alt"></i></span>Blueprints</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-10"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>Input</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-10-1">Controles</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-10-2">Funciones</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-11"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>Time</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-12"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>Utilidades</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-12-1">StringFormatter</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-12-2">Vector2</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-12-3">Vector3</a></li>
					<li class="nav-item"><a class="nav-link scrollto" href="#item-12-4">Vector4</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-12-5">Random</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-13"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>Windows</a></li>
					<li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-14"><span class="theme-icon-holder me-2"><i class="fas fa-book-reader"></i></span>Importación de archivos</a></li>
				    <!-- <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#section-9"><span class="theme-icon-holder me-2"><i class="fas fa-lightbulb"></i></span>FAQs</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-9-1">Instalación</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-9-2">Motor</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item-9-3">Otros</a></li> -->
			    </ul>

		    </nav><!--//docs-nav-->
	    </div><!--//docs-sidebar-->
	    <div class="docs-content">
		    <div class="container">
			    <article class="docs-article" id="section-1">
				    <header class="docs-header">
					    <h1 class="docs-heading">Introducción <span class="docs-time">Ultima actualizacion: 2022-06-01</span></h1>
					    <section class="docs-intro">
						    <p>Esta es la API completa de nuestro motor LOVE. Contiene las especificaciones para cada modulo y clase del motor. Ademas de como crear escenas y objetos con sus respectivos componentes. </p>



						</section><!--//docs-intro-->
				    </header>
			    </article>
			    
			    <article class="docs-article" id="section-2">
				    <header class="docs-header">
					    <h1 class="docs-heading">Instalación</h1>
					    <section class="docs-intro">
						    <p>Para empezar a usar el motor LoveEngine, lo primero que debemos hacer es crear un proyecto nuevo de visual studio para c++. Una vez creado, abrimos la configuración del proyecto y nos aseguramos de que las siguientes opciones están configuradas de la siguiente forma:
								</p>

							<p>El tipo de configuracion de salida debe ser .dll y el nombre del archivo de salida para release Game.dll y para debug Game_d.dll. 
							</p>

							<div class="callout-block callout-block-warning">
								<div class="content">
									<h4 class="callout-title">
										<span class="callout-icon-holder me-1">
											<i class="fas fa-bullhorn"></i>
										</span><!--//icon-holder-->
										Aviso
									</h4>
									<p>De no llamarse asi los archivos la dll del juego no va a funcionar bien con el motor.</p>
								</div><!--//content-->
							</div><!--//callout-block-->
							

							<p>Dentro de las opciones del vinculador, direcciones de inclusión adicionales, incluir [TODO: cuando se compile el motor con el bat, marcar la dirección de salida de ECS].
							</p>

							<p>Dentro de las opciones del vinculador, en la sección de entrada, añadir como dependencia adicional ECS.dll para la configuración en release y ECS.dlll para el modo debug.
							</p>

							<p>Dentro de las opciones de C/C++, direcciones de inclusión adicionales, incluir [TODO: cuando se compile el motor, incluir el directorio de salida de los headers].
							</p>


						</section><!--//docs-intro-->
				    </header>
			    </article><!--//docs-article-->
			    
				<article class="docs-article" id="section-create">
				    <header class="docs-header">
					    <h1 class="docs-heading">Crea tu propio componente</h1>
					    <section class="docs-intro">
						    <p>Para crear tu propio Componente tienes que crear un archivo .h, recomendable el crear tambien un .cpp para definir los metodos del mismo. 
								Este archivo .h tiene que incluir la clase Componente.h y hacer que el componente que creeis herede de esta como se ve en el ejemplo acontinuacion. 
							</p>
							<div class="docs-code-block">
								<pre class="shadow-lg rounded"><code class="json hljs">#include <Component.h>

namespace LoveEngine {
	namespace Input {
		class InputManager;
	}
									
	namespace ECS {
		class Transform;
		class RigidBody;
											
		class MovimientoJugador : public Component {
												
			private:
				float MAX_SPEED = 15;
									
				RigidBody* bossRb;
				Transform* bossTr;	

				float movementZ = 0;
				float movementX = 0;
									
				float dashDelay = 1; //Cada cuanto tiempo puedes dashear
			public:
				void init() override;
				void postInit() override;
				void update() override;
				void stepPhysics() override;				
				void receiveMessage(Utilities::StringFormatter& message) override;
				void receiveComponent(int, Component*) override;
									
				void dash();
				inline float getSpeed() { return speed; };
				inline float getMaxSpeed() { return MAX_SPEED; };
			};
	}
}</code></pre>

<div class="callout-block callout-block-info">
                            
	<div class="content">
		<h4 class="callout-title">
			<span class="callout-icon-holder me-1">
				<i class="fas fa-info-circle"></i>
			</span><!--//icon-holder-->
			Nota
		</h4>
		<p> Se aconseja poner override en los <a href="#item-3-2"> metodos predifinidos</a> por la clase componente</p>
	</div><!--//content-->
</div><!--//callout-block-->

<p>Solo con esto ya hemos creado nuestro componente, aunque aún no hemos terminado. Si bien este componente ya es válido y completamente funcional, éste sólo podrá ser accedido a través de otros archivos de código en c++, pues aún no lo hemos declarado para las escenas creadas en Lua. Es recomendable crear un archivo donde definir todos los componentes del juego. El proceso de declaración de componentes en Lua es el siguiente:</p>
							<p>	-Incluir la cabecera ComponentFactory.h</p>
								<p>	-Acceder al singleton ‘ComponentFactory’</p>
									<p>	-Crear un puntero a ‘ComponentCreatorTemplate’. Como argumento de plantilla recibirá como parámetro el componente creado, y de parámetro una cadena de texto la cual representará el nombre con el que queremos que se asocie este componente a Lua.</p>
										<p>	-Registrar con el método ‘registerComponent’ mandando como parámetro el puntero de creación de componente creado.</p>


							<div class="docs-code-block">
								<pre class="shadow-lg rounded"><code class="json hljs">
template <class t>
	void newComponent(std::string name) {
		inst->registerComponent(new ComponentCreatorTemplate<t>(name));
	}
}</code></pre>
							<div class="callout-block callout-block-info">
                            
								<div class="content">
									<h4 class="callout-title">
										<span class="callout-icon-holder me-1">
											<i class="fas fa-info-circle"></i>
										</span><!--//icon-holder-->
										Nota
									</h4>
									<p> inst es el puntero al singleton de la factoría de componentes</p>
								</div><!--//content-->
							</div><!--//callout-block-->


							<p>De esta forma, cada vez que queramos declarar un componente nuevo bastaría con llamar la función de la siguiente forma:</p>

							<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs"> newComponent<ComponenteDePrueba>(“ComponenteDePrueba”);</code></pre>
		
								<div class="callout-block callout-block-info">
                            
									<div class="content">
										<h4 class="callout-title">
											<span class="callout-icon-holder me-1">
												<i class="fas fa-info-circle"></i>
											</span><!--//icon-holder-->
											Nota
										</h4>
										<p> Es necesario haber incluido la cabecera del componente creado</p>
									</div><!--//content-->
								</div><!--//callout-block-->

								<p> Este acercamiento a la hora de crear componentes nos dota de varias ventajas:</p>
								<p>		 -Poder crear componentes auxiliares: Componentes que se usan únicamente en ciertas partes del código en c++ pero que no queremos hacer públicos desde Lua</p>
								<p>		 -Poder tener variaciones de nombres entre c++ y Lua, en el caso de que tengamos algún nombre más técnico en el código fuente que no sea muy práctico de usar en Lua</p>
								<p>	  	 -Poder asociar varios nombres al mismo componente. ¿No os decidís si llamar a un componente AudioManager o SoundManager? Prueba a ponerle ambos</p>
						</section><!--//docs-intro-->
				    </header>
				   


			    </article><!--//docs-article-->
			    
				<article class="docs-article" id="section-createscene">
				    <header class="docs-header">
					    <h1 class="docs-heading">Crea tu propia escena</h1>
					    <section class="docs-intro">
						    <p>Las escenas se crearán usando Lua como lenguaje de scripting. El punto de entrada para la creación de escenas deberá ser en un archivo llamado 
								‘Scenes.lua’, situado en la raíz de la carpeta resources. Aunque no es necesario que las escenas estén definidas dentro de este archivo 
								siempre que se importe el módulo del archivo de Lua en el que se haya creado.
	
								Para importar un archivo de lua basta con usar la función ‘require’ seguido de una cadena con el nombre del fichero.
								</p>
	
								<div class="callout-block callout-block-info">
								
									<div class="content">
										<h4 class="callout-title">
											<span class="callout-icon-holder me-1">
												<i class="fas fa-info-circle"></i>
											</span><!--//icon-holder-->
											Nota
										</h4>
										<p> Para más información sobre cómo usar Lua  pulse <a href="https://www.lua.org/manual/5.1/es"> aquí</a>.</p>
									</div><!--//content-->
								</div><!--//callout-block-->
	
								<p>Las escenas van numeradas empezando desde cero, y deben ser llamadas ‘scene’ seguido de su respectivo índice. LoveEngine permite dos formas 
									de definir las escenas: en forma de tabla y de manera funcional. </p>
								
									
									<section class="docs-section" id="item-3-1-1">
										<h2 class="section-heading">Forma de Tabla</h2>
										<p>Para crear de esta forma una escena hay que crear una variable global en Lua con el nombre de la escena correspondiente, por ejemplo ‘scene0’ para la 
											tercera escena del juego (recordemos que las escenas empiezan siendo indexadas desde cero), y abrimos corchetes para empezar a definir nuestra escena.
											</p>
											<p>Definir la escena: En esta tabla se define el nombre de la escena (mediante el atributo ‘name’) y se define el atributo ‘objects’ el cual es un vector de objetos. </p>
	
											<p>Definir un objeto: Un objeto contiene dos atributos que se pueden modificar. Siendo el primero de ellos el nombre con el atributo ‘name’, en caso de que queramos que un objeto tenga un nombre predefinido, y el vector de componentes que viene asociado al objeto con el atributo ‘components’
											</p>
											<p>Definir un componente: Para definir un componente hay que asignar de manera obligatoria el atributo ‘type’, el cual define el tipo del componente. El componente que añadamos aquí deberá haber sido declarados desde el proyecto de c++ para poder ser usado desde Lua. Todos los componentes que vienen con LoveEngine vienen ya declarados. 
											Además, un componente viene con un segundo atributo opcional llamado ‘info’. Este atributo es una cadena de texto la cual cuenta con los parámetros que serán pasados al objeto en su creación. Para más información sobre el paso de parámetros a objetos consultar el apartado <a  href="#item-12-1" >stringFormatter</a>.
											</p>
	
											<p>Un ejemplo de una escena definida mediante una tabla es el siguiente:
												</p>
	
												<div class="docs-code-block">
													<pre class="shadow-lg rounded"><code class="json hljs">scene0 = {
			name = “Menu de Pausa”,
			objects = {
					{
						name = “Fondo”,
						components = {
								{
										type = “Image”
										info = [[
										material: pauseMenu; 
												width: 1280;
												  height : 720;
										]]
								}
							}
						}, 
						{
							name = “BotonContinuar”,
							components = {
								{
									type = “ContinueButton”
									info = [[
									material: buttonMaterial; 
									]]
								}
							}
						}
			}
	}	</code></pre>
												</div><!--//docs-code-block-->
									</section><!--//section-->
	
									<div class="callout-block callout-block-info">
								
										<div class="content">
											<h4 class="callout-title">
												<span class="callout-icon-holder me-1">
													<i class="fas fa-info-circle"></i>
												</span><!--//icon-holder-->
												Nota
											</h4>
											<p> Esta escena asume que existe el componente ‘ContinueButton’ y los materiales buttonMaterial y pauseMenu.</p>
										</div><!--//content-->
									</div><!--//callout-block-->
	
	
									<p>Por último, una escena puede definir un último atributo, el atributo ‘code’. Este atributo debe ser una 
										función y se comporta igual que la creación de una escena funcional. Útil en caso de querer realizar operaciones
										 o instrucciones de Lua (como condicionales y bucles) o usar querer usar funcionalidades exclusivas de la creación de escenas de forma funcional.
									</p>
						</section><!--//docs-intro-->



						<section class="docs-section" id="item-3-1-2">
							<h2 class="section-heading">Funcional</h2>
							<p>Para crear de esta forma una escena hay que crear funcion en LUA y darle el nombre de la escena que vamos a usar.
								</p>
								<p>Definir la escena: En esta funcion se define el nombre de la escena (mediante el atributo ‘name’). </p>

								<p>Definir un objeto: Un objeto contiene dos atributos que se pueden modificar. Siendo el primero de ellos el nombre con el atributo ‘name’, en caso de que queramos que un objeto tenga un nombre predefinido, y el vector de componentes con una serie de metodos que tienen los objetos.
								</p>
								<p>Definir un componente: Para definir un componente hay que asignar de manera obligatoria el componente a gameObject (addComponent). El componente que añadamos aquí deberá haber sido declarados desde el proyecto de c++ para poder ser usado desde Lua. Todos los componentes que vienen con LoveEngine vienen ya declarados. 
								Además, un componente viene con un segundo metodo opcional llamado (sendMsg). Este metodo es una cadena de texto la cual cuenta con los parámetros que serán pasados al objeto en su creación. Para más información sobre el paso de parámetros a objetos consultar el apartado  <a  href="#item-12-1" >stringFormatter</a>.
								</p>

								<p>Un ejemplo de una escena definida mediante una tabla es el siguiente:
									</p>

									<div class="docs-code-block">
										<pre class="shadow-lg rounded"><code class="json hljs">function sceneOverworld() -- Overworld
		scene:name("Escena Overworld")
										
		--MURO1
		local muro1 = scene:createObject("muro1")
		local muroTr1 = muro1:addComponent("Transform")
		muroTr1:sendMsg([[
			scale: 1,10,150;
			position: -150,10,0;
			rotation: 0,0,0;
		]])
		local rBMuro1 = muro1:addComponent('Rigidbody')
		rBMuro1:sendMsg([[
			trigger: false;
			state: kinematic;
			mass: 0.0;
			shape: cube;
			restitution: 0.9;
			colliderScale: 10,30,150;
		]])
										
										
		--MURO2
		local muro2 = scene:createObject("muro2")
		local muroTr2 = muro2:addComponent("Transform")
										
		muroTr2:sendMsg([[
			scale: 1,10,150;
			position: 150,10,0;
			rotation: 0,0,0;
		]])
										
		local rBMuro2 = muro2:addComponent('Rigidbody')
		rBMuro2:sendMsg([[
			trigger: false;
			state: kinematic;
			mass: 0.0;
			shape: cube;
			restitution: 0.9;
			colliderScale: 10,30,150;
		]])
end</code></pre>
									</div><!--//docs-code-block-->
						</section><!--//section-->

			</section><!--//docs-intro-->
				    </header>
				   
			    </article><!--//docs-article-->

			    <article class="docs-article" id="section-3">
				    <header class="docs-header">
					    <h1 class="docs-heading">ECS</h1>
					    <!-- <section class="docs-intro">
						    <p>Section intro goes here. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque finibus condimentum nisl id vulputate. Praesent aliquet varius eros interdum suscipit. Donec eu purus sed nibh convallis bibendum quis vitae turpis. Duis vestibulum diam lorem, vitae dapibus nibh facilisis a. Fusce in malesuada odio.</p>
						</section> -->
				    </header>
				     <section class="docs-section" id="item-3-1">
						<h2 class="section-heading">Escenas</h2>
						<p><p>Clase basica de las escenas que contiene los metodos que ejecuta la escena.  </p>

						<div class="table-responsive my-4">
							<table class="table table-bordered">
								<tbody>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void init()</a></th>
										<td> Metodo que se llama al crear la escena y ejecuta el init de todos los gameobjects de la escena. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void postInit() </a></th>
										<td> Meotodo que se llama al crear la escena despues del init y ejecuta el postInit de todos los gameobjects  de la escena. </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> void update()</a></th>
										<td> Metodo que se llama cada vez que se actualiza el juego y ejecuta el update de todos los gameobjects  de la escena. </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void removeObjects()</a></th>
										<td> Metodo que borra todos los gameobjects de la escena.  </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void stepPhysics()</a></th>
										<td> Metodos que se llama cada vez que se actualizan las fisicas del juego y llama a cada stepPhysics de los gameObjects de la escena. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void onSceneUp()</a></th>
										<td> Metodos que se llama al activarse la escena y llama a cada onSceneUp de los gameObjects de la escena. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void onSceneDown()</a></th>
										<td> Metodos que se llama al desactivarse la escena y llama a cada onSceneDown de los gameObjects de la escena. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">GameObject* persistentGameObject()</a></th>
										<td> Devuelve un puntero al objeto persistente de la escena. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">GameObject* find(std::string name)</a></th>
										<td> Devuelve un puntero al gameobject de la escena de nombre name, encaso de no encontrarlo devuelve nullptr. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void setName(std::string newname)</a></th>
										<td>El nombre de la escena pasa a ser newname. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">std::list<GameObject*> const& getGameObjects()</a></th>
										<td> Devuelve la lista de gameobjects de la escena. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">GameObject* createGameObject(std::string name)</a></th>
										<td> Devuelve un puntero a un gameobject que crea en la escena de nombre name.  </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void    setMainCamera(Camera*)</a></th>
										<td> Establece la camara principal mla enviada como parametro.  </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Camera* getMainCamera()</a></th>
										<td> Devuelve la camara principal de la escena. </td>
									</tr>
								</tbody>
							</table>
						</div><!--//table-responsive-->

					</section><!--//section-->
					
					<section class="docs-section" id="item-3-2">
						<h2 class="section-heading">Componentes</h2>
						<p><p>Clase basica de los componentes y de la cual todos tiene que heredar. </p>
						<p>		#include  &ltComponent.h&gt</p></p>

						<p>	Esta clase tiene una serie de metodos los cuales son comunes a todos los componentes y cada uno de estos se ejecuta en un momento diferente del juego.</p></p>


						<div class="table-responsive my-4">
							<table class="table table-bordered">
								<tbody>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">virtual void receiveComponent(int, Component*) </a></th>
										<td> Recibe un int y un componente. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">virtual void receiveGameObject(int, GameObject*) </a></th>
										<td> Recibe un int y un gameobject. </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> Component* sendFormattedString(std::string mssg)</a></th>
										<td> AYUDA</td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> virtual void receiveString(std::string mssg)</a></th>
										<td> Recibe un string.  </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void remove(Component* comp) </a></th>
										<td> Borra el componente comp. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> void remove(GameObject* go)</a></th>
										<td> Borra el gameObject go. </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> void remove()</a></th>
										<td> Borra el propio gameObject. </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> void setActive(bool val)</a></th>
										<td>Si val es tru activa el componente, lo desactiva en caso contrario.  </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> bool isActive()</a></th>
										<td> Devuelve true si el componente esta activo, false encaso contrario.  </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void swapActive() </a></th>
										<td>Cambia el estado actual de componente, entre activo y inactivo. </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">virtual void init()  </a></th>
										<td>Metodo que se llama al crearse el componente.  </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">virtual void postInit() </a></th>
										<td>Metodo que se llama al crearse el componente despues del init.  </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">virtual void update() </a></th>
										<td>Metodo que se llama cada vez que se actualiza el juego.  </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">virtual void stepPhysics() </a></th>
										<td>Metodo que se llama cada vez que actualizan las fisicas del juego. </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">virtual void activated() </a></th>
										<td> Metodo que se llama cada vez que se activa el compoennte. </td>
									</tr>
									
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">virtual void deActivated() </a></th>
										<td> Metodo que se llama cada vez que se desactiva el componente. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">virtual void onSceneUp() </a></th>
										<td>Metodo que se llama cada vez que se activa la escena en la que esta el componente. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">virtual void onSceneDown() </a></th>
										<td>Metodo que se llama cada vez que se sale de la escena en la que esta el componente. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">virtual void receiveMessage(Utilities::StringFormatter& sf) </a></th>
										<td>Metodo que recibe el mensaje de LUA en forma de <a href="#item-12-1"> stringformatter</a>.  </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">virtual void colliding(GameObject* other )</a></th>
										<td>Metodo que se llama cuando el gameobject del componente esta chocando con el gameobject other. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">virtual void enterCollision(GameObject* other) </a></th>
										<td>Metodo que se llama cuando el gameobject del componente empieza a chocar con el gameobject other. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">virtual void exitCollision(GameObject* other) </a></th>
										<td>Metodo que se llama cuando el gameobject del componente deja de chocar con el gameobject other. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">GameObject* createObject(std::string name) </a></th>
										<td> Devuelve un puntero al gameobject que crea con nombre name.  </td>
									</tr>

								</tbody>
							</table>
						</div><!--//table-responsive-->

					</section><!--//section-->


					<section class="docs-section" id="item-3-33">
						<h2 class="section-heading">GameObjects</h2>
						<p>Los gameobject son los objetos del juego, estos pueden tener distintos componentes, tanto los que ya vienen por defecto como los propios.  </p>

						<p>Para gestionar a los gameobjects existen divesos metodos. </p>


						<div class="table-responsive my-4">
							<table class="table table-bordered">
								<tbody>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Scene* getCurrentScene()</a></th>
										<td> Devuelve un puntero a la escena en la que esta el gameObject.  </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">componenteEjemplo* addComponent(bool init)</a></th>
										<td> Recibe puntero al componente que se le añade al gameobject. Es de tipo template,  por lo que puede devolver cualquier tipo de componente. Si init es true se ejecuta el init y el postInit de los componentes, por defecto es false. </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Component* createComponent(std::string comp)</a></th>
										<td> Crea un componente al que le corresponde el nombre comp y lo devuelve como puntero. </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> bool hasComponent()</a></th>
										<td> Metodo de tipo template al que se le envia un componente y devuelve true si esta en el gameObject y false en caso contrario.  </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void removeComponent() </a></th>
										<td> Metodo de tipo template al que se le envia un componente y se borra del gameObject en caso de tenerlo. </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> void removeComponent(Component* comp)</a></th>
										<td> Metodo al que se le envia como parametro un componente y este es borrado del gameObject si existe. </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> componenteEjemplo* getComponent()</a></th>
										<td>Metodo que devuelve el primer componente del gameobject del tipo enviado en el template, devuelve nullptr en caso de no haber. </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> std::vector<componenteEjemplo*> getComponents()</a></th>
										<td>Metodo que devuelve todos los compoenntes del gameobject del tipo enviado en el template, devuelve un vector vacio en caso de no haber.  </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> void activate(bool value)</a></th>
										<td> Activa o desactiva el gameobject en funcion del boleano value.  </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void removeGameObject() </a></th>
										<td>Borra el gameObject. </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">bool isEnabled() </a></th>
										<td>Devuelve true si el gameObject esta activo, false en caso contrario.  </td>
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">GameObject* createEmptyGameObject(std::string name) </a></th>
										<td>Devuelve un puntero a un gameObject que crea vacio, con nombre name.  </td>
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void sendMessage(std::string mssg)</a></th>
										<td>Envia el string mssg a todos los componentes del gameObject.  </td>
									</tr>

								</tbody>
							</table>
						</div><!--//table-responsive-->

					</section><!--//section-->
			    </article><!--//docs-article-->
			    
			    <article class="docs-article" id="section-5">
				    <header class="docs-header">
					    <h1 class="docs-heading">LUA</h1>
					    <section class="docs-intro">
						    <p>Funciones de LUA que se usan a la hora de crear las escenas para el juego.</p>
						</section><!--//docs-intro-->
				    </header>
				     <section class="docs-section" id="item-5-1">
						<h2 class="section-heading">Scene</h2>
						<p>1- La funcion name le da un nombre a la escena</p>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">scene:name("Escena Ejemplo")</code></pre>

							<p>2- La funcion createObject crea un objeto en la escena, el parametro es el nombre del objeto.</p>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">local muro1 = scene:createObject("muro1")</code></pre>

					</section><!--//section-->
					
					<section class="docs-section" id="item-5-2">
						<h2 class="section-heading">GameObject</h2>
						<p>1- La funcion addComponent añade un componente al gameObject con el nombre enviado por parametro. </p>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">local muroTr1 = muro1:addComponent("Transform")</code></pre>

							<p>2- La funcion sendMsg envia un string al gameObject. </p>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">muro1:sendMsg([[
	Texto de ejemplo
]])</code></pre>

					</section><!--//section-->
					
					<section class="docs-section" id="item-5-3">
						<h2 class="section-heading">Component</h2>
						
							<p>1- La funcion sendMsg envia un string al componente dado con los parametros del componente. </p>
						<div class="docs-code-block">
							<pre class="shadow-lg rounded"><code class="json hljs">muroTr1:sendMsg([[
	scale: 1,10,150;
	position: -150,10,0;
	rotation: 0,0,0;
]])</code></pre>

<p>2- La funcion sendMsg envia un string al componente dado con los parametros del componente. </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">muroTr1:sendString([[
	Mensaje al compoennte
]])</code></pre>

<p>3- La funcion sendComponent envia un componente y un int al componente  </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">muroTr1:sendComponent(1,sueloTr)</code></pre>

<p>4- La funcion sendgameObject envia un gameObject y un int al componente </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">muroTr1:sendGameObject(0, suelo)</code></pre>


					</section><!--//section-->
					<section class="docs-section" id="item-5-4">
						<h2 class="section-heading">Window</h2>

						<p>1- La funcion setWindowSize establece el tamaño de la ventana.  </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">window:setWindowSize(200,200)</code></pre>

	<p>2- La funcion getWidth devuelve el ancho de la ventana.  </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">local w = window:getWidth()</code></pre>

	<p>3- La funcion getHeight devuelve la altura de la ventana.   </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">local h = window:getHeight()</code></pre>

	<p>4- La funcion getWindowTitle devuelve el nombre de la ventana.  </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">local name = window:getWindowTitle()</code></pre>

	<p>5- La funcion  setWindowTitle cambia el nombre de la ventana </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">window:setWindowTitle("escena 1")</code></pre>

	<p>6- La funcion setFullScreen pasa al modo pantalla completa.  </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">window:setFullScreen()</code></pre>

	<p>7- La funcion setIcon cambia el icono de la ventana por el enviado  </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">window:setIcon("icon.jpg")</code></pre>

					</section><!--//section-->
					<section class="docs-section" id="item-5-5">
						<h2 class="section-heading">Blueprints</h2>
						
						<p>1- La funcion createObject crea el objeto del Blueprint.  </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">AYUDA</code></pre>

	<p>2- La funcion fillObject llama a los metodos init de los componentes del Blueprint.   </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">AYUDA</code></pre>

	<p>3- La funcion addComponent añade un compoennte al objeton del Blueprint.   </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">AYUDA</code></pre>

					</section><!--//section-->
					<section class="docs-section" id="item-5-6">
						<h2 class="section-heading">General</h2>
						<p>1- La funcion random genera un numero aleatorio.  </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">local num = random()</code></pre>

	<p>2- La funcion randomBetween genera un numero aleatorio entre dos dados.   </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">local num = randomBetween(0,10)</code></pre>

	<p>3- La funcion round redondea el numero dado   </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">local centerx = round((100 + 300) * 0.5)</code></pre>

	<p>4- La funcion floor devuelve el entero mayor a un decimal dado.   </p>
	<div class="docs-code-block">
		<pre class="shadow-lg rounded"><code class="json hljs">local num = floor(10.4)</code></pre>

		<p>5- La funcion ceil redondea un numero hacia arriba siempre.   </p>
		<div class="docs-code-block">
			<pre class="shadow-lg rounded"><code class="json hljs">local num = ceil(10.4)</code></pre>
					</section><!--//section-->
					<section class="docs-section" id="item-5-7">
						<h2 class="section-heading">Global variable</h2>
						<p>1- La variable scene corresponde a la escena  </p>

	<p>2- La variable sceneCount lleva el numero de escenas diferentes que existen en el juego   </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">sceneCount = 11;</code></pre>

	<p>3- La variable persistentGameObject es un gameObject que no desaparece entre las escenas y actua como un gameobject mas.  </p>
<div class="docs-code-block">
	<pre class="shadow-lg rounded"><code class="json hljs">persistentObject:addComponent("Transform")</code></pre>
					</section><!--//section-->
			    </article><!--//docs-article-->
			    
			    
		        <article class="docs-article" id="section-6">
				    <header class="docs-header">
					    <h1 class="docs-heading">SceneManager</h1>
					    <section class="docs-intro">
						    <p>Clase que se encarga de la gestion de escenas.</p>
						</section><!--//docs-intro-->
				    </header>
				     <section class="docs-section" id="item-6-1">
						<h2 class="section-heading">Formas de cambiar escenas</h2>
						<p>Se pueden hacer distintas operaciones en funcion de lo que se quiera hacer con la escena gracias al enum SceneLoad.  </p>
						<div class="table-responsive my-4">
							<table class="table table-bordered">
								<tbody>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">PUSH </a></th>
										<td>Añade a la pila de escenas la escena enviada.  </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> SWAP </a></th>
										<td>Cambia la cima de la pila por la escena enviada.  </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">POP </a></th>
										<td>Borra la cima de la pila.  </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">CLEAR </a></th>
										<td>Vacia la pila de escenas y mete la enviada.  </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> EXIT</a></th>
										<td>Vacia la pila de escenas y sale de la ejecución. </td>
									
									</tr>

								</tbody>
							</table>
						</div><!--//table-responsive-->
					
					</section><!--//section-->
					
					<section class="docs-section" id="item-6-2">
						<h2 class="section-heading">Funciones</h2>
						<p>Lista de metodos que puede llamar el SceneManager. </p>

						<div class="table-responsive my-4">
							<table class="table table-bordered">
								<tbody>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">static  SceneManager* getInstance(); </a></th>
										<td>Devuelve un puntero al SceneManager.  </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> ECS::Scene* getCurrentScene(</a></th>
										<td>Devuelve un puntero a la escena actual. </td>
									
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> int sceneCount()</a></th>
										<td>Devuelve el numero de esscenas totales.  </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">int currentSceneIdx() </a></th>
										<td> Devuelve la posicion en el array de escenas que le correponde a la escena actual. </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">std::string currentSceneName() </a></th>
										<td>Devuelve el nombre de la escena actual.  </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">int stackedScenes() </a></th>
										<td>Devuelve el numero de escenas que hay en la pila.  </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void changeScene(int SceneIdx, SceneLoad type) </a></th>
										<td>En funcion del parametro type, hace una cosa u otra como ya esta explicado anteriormente.  </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void tryChangeScene() </a></th>
										<td>Comprueba si la escena debe cambiar, y la actualiza </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> void initiliseScenes()</a></th>
										<td>Finaliza la creación de escenas, para no añadir escenas en medio de la ejecución </td>
									
									</tr>

								</tbody>
							</table>
						</div><!--//table-responsive-->
					</section><!--//section-->
					
					
			    </article><!--//docs-article-->
			    
			    
			    <article class="docs-article" id="section-7">
				    <header class="docs-header">
					    <h1 class="docs-heading">Blueprints</h1>
					    <section class="docs-intro">
						    <p>Clase que se utliliza para crear plantillas de gameobjects para luego usarlos en tu juego.</p>

							<div class="table-responsive my-4">
								<table class="table table-bordered">
									<tbody>
	
										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">static Blueprint* getInstance()</a></th>
											<td>Devuelve un puntero a Bluprint. </td>
										
										</tr>
	
										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">Component* addComponent(GameObject* gameObject, std::string const& component, bool init)</a></th>
											<td>Añade el componente de nombre component al objeto gameObject, el boleano init indica si se ejecutan los metodos init y postInit del mismo, por defecto igual a true.Devuelve un puntero al componente
												y nullptr en caso de no haber podido crearlo.
											</td>
										
										</tr>
	
										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">GameObject* spawnObject(Scene* scene, std::string const& name, bool init)</a></th>
											<td>Crea el objeto con nombre name, en la scena scene, el boleano init indica si se ejecutan los metodos init y postInit del mismo, por defecto igual a true. Devuelve un puntero al gameObject
												y nullptr en caso de no haber podido crearlo.</td>
										
										</tr>
	
										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">GameObject* fillObject (GameObject* gameObject, std::string const& name, bool init)</a></th>
											<td>Carga el objeto gameObject con nombre name y ejecuta el init de todos sus metodos. Devuelve un puntuero al objeto si se ha ejecutado bien y nullptr en caso de fallo. </td>
										
										</tr>
	
	
									</tbody>
								</table>
							</div><!--//table-responsive-->
						</section><!--//docs-intro-->
				    </header>
				
			    </article><!--//docs-article-->

				<article class="docs-article" id="section-10">
				    <header class="docs-header">
					    <h1 class="docs-heading">Input</h1>
					    <section class="docs-intro">
						    <p>Clase que usamos para manejar el input en el motor.</p>
						</section><!--//docs-intro-->
				    </header>
				     <section class="docs-section" id="item-10-1">
						<h2 class="section-heading">Teclas y Botones</h2>
						<p>Aqui estan los enum que permiten identificar las diferentes teclas y botones que se usan. </p>

						<div class="table-responsive my-4">
							<table class="table table-bordered">
								<tbody>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">InputKeys</a></th>
										<td>A = 4, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z,
											RIGHT = 80, LEFT, DOWN, UP, TAB = 43, CTRL = 224, SHIFT = 225,
											SPACE = 44, ESCAPE = 41, ENTER = 88 </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">MouseState</a></th>
										<td> NONE, CLICK_L, CLICK_R, CLICK_M</td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">ControllerButton</a></th>
										<td> A, B, X, Y, BACK, GUIDE, START, 
											LSTICK, RSTICK, LS, RS,
											DPAD_UP, DPAD_DOWN, DPAD_LEFT, DPAD_RIGHT,
											LB, LT, RB, RT</td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">psControllerButton</a></th>
										<td>X, CIRCLE, TRIANGLE, SQUARE, BACK, GUIDE, START,
											LSTICK, RSTICK, LS, RS,
											DPAD_UP, DPAD_DOWN, DPAD_LEFT, DPAD_RIGHT,
											LB, LT, RB, RT </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">ControllerButtonState</a></th>
										<td>UP, DOWN, HOLD, NONE </td>
									
									</tr>

								</tbody>
							</table>
						</div><!--//table-responsive-->
						<div class="callout-block callout-block-info">
								
							<div class="content">
									<h4 class="callout-title">
									<span class="callout-icon-holder me-1">
										<i class="fas fa-info-circle"></i>
									</span><!--//icon-holder-->
										Nota
									</h4>
								<p>Las teclas de mando corresponden a un mando de XBOX. </p>
							</div><!--//content-->
						</div><!--//callout-block-->

					</section><!--//section-->
					
					<section class="docs-section" id="item-10-2">
						<h2 class="section-heading">Funciones</h2>
						<p>Aqui tienes una lista de metodos que comprueban el input. </p>
					</section><!--//section-->
					
					<div class="table-responsive my-4">
						<table class="table table-bordered">
							<tbody>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">bool isKeyPressed(InputKeys key)</a></th>
									<td>Devuelve true si la key esta siendo pulsada, false en caso contrario. </td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#"> bool keyJustPressed(InputKeys key)</a></th>
									<td> Devuelve true si la key se ha pulsado una vez, false en caso contrario. </td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#"> bool mousePressed(MouseState state)</a></th>
									<td> Devuelve true si el estado del raton correponde con state, false en caso contrario. </td>
								
								</tr>
								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">bool anyKeyPressed() </a></th>
									<td> Devuelve true sio se esta pulsando alguna tecla, false en caso contrario. </td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#"> float mouseWheel()</a></th>
									<td>Devuelve el valor del movimiento de la rueda del raton.  </td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">Utilities::Vector2<int> mousePosition() </a></th>
									<td>Devuelve en eun vector2 la posición del raton en la pantalla.  </td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#"> Utilities::Vector2<float> relativeMousePosition()</a></th>
									<td>Devuelve las posiciones que se ha movido el raton respecto a la ultima actualizacion. </td>
								
								</tr>
								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">void mouseVisibility(bool inGame) </a></th>
									<td> Cambia la visibilidad del raton, si inGame es true se deja de ver y se ve en caso contrario. </td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">bool justClicked() </a></th>
									<td>Devuelve true si se acaba de clickar, false en caso contrario. </td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">bool controllerConected() </a></th>
									<td>Devuelve true si el mando esta conectado, false en caso contrario. </td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#"> bool isControllerButtonPressed(ControllerButton b)</a></th>
									<td> Devuelve true si se esta pulsando de alguna forma el boton del mando b, false en caso contrario </td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#"> bool isControllerButtonState(ControllerButtonState s)</a></th>
									<td> Devuelve true si el boton que se esta pulsando lo hace de la forma s, false en caso contrario. </td>
								
								</tr>

							</tbody>
						</table>
					</div><!--//table-responsive-->

					
			    </article><!--//docs-article-->

				<article class="docs-article" id="section-11">
				    <header class="docs-header">
					    <h1 class="docs-heading">Time</h1>
					    <section class="docs-intro">
						    <p>Clase que se encarga de gestionar el tiempo en el motor y tienes accesibles diversos metodos y variables.</p>


							<div class="table-responsive my-4">
								<table class="table table-bordered">
									<tbody>
	
										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">static Time* getInstance() </a></th>
											<td> Metodo que devuelve un puntero al tiempo </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#"> float calculateFrameRate()</a></th>
											<td>Metodo que devuelve el numero de frames por segundo. </td>
										
										</tr>
	
										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">deltaTime </a></th>
											<td>float que corresponde al Deltatime del motor. </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">physicsTime </a></th>
											<td>Tiempoque tarda en actualizarse las fisicas. </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">timeSinceStart </a></th>
											<td>Tiempo desde que se empezo a ejecutar el juego </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">frameCount </a></th>
											<td> Numero de frames desde que se empezo a ejecutar el motor. </td>
										
										</tr>
	
									</tbody>
								</table>
							</div><!--//table-responsive-->


						</section><!--//docs-intro-->
				    </header>
				     
			    </article><!--//docs-article-->


				<article class="docs-article" id="section-12">
				    <header class="docs-header">
					    <h1 class="docs-heading">Utilidades</h1>
					    <section class="docs-intro">
						    <p>Libreria de ayuda que contiene elementos generales del motor.</p>
						</section><!--//docs-intro-->
				    </header>
				     <section class="docs-section" id="item-12-1">
						<h2 class="section-heading">StringFormatter</h2>
						<p>Clase que se encarga de traducir los mensajes que se envian por LUA al formato adecuado. </p>

							<div class="docs-code-block">
								<pre class="shadow-lg rounded"><code class="json hljs">[[
	intEjemplo: 1;
	floatEjemplo: 1.3;
	boolEjemplo: true;
	charEjemplo: a;
	StringEjemplo: Hola;
	vector3Ejemplo: 1, 2, 3;
	vector4Ejemplo: 1, 2, 3, 4
]]</code></pre>

					<p>Contiene estos metodos para extraer la informacion de un string ya enviado en la constructora: </p>					

					<div class="table-responsive my-4">
						<table class="table table-bordered">
							<tbody>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">void clear()</a></th>
									<td>Limpia la informacion del string StringFormatter. </td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">void addString(std::string message)</a></th>
									<td>Añade informacion al stringFormatter. </td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">float getFloat(std::string name)</a></th>
									<td>Devuelve el float con el name correspondiente, para el ejemplo anterior seria floatEjemplo.</td>
								
								</tr>
								
								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">bool getBool(std::string name)</a></th>
									<td>Devuelve el bool con el name correspondiente, para el ejemplo anterio seria boolEjemplo.</td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">int getInt(std::string name)</a></th>
									<td>Devuelve el int con el name correspondiente, para el ejemplo anterio seria intEjemplo.</td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">char getChar(std::string name)</a></th>
									<td>Devuelve el char con el name correspondiente, para el ejemplo anterio seria charEjemplo.</td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">std::string getString(std::string name)</a></th>
									<td>Devuelve el string con el name correspondiente, para el ejemplo anterio seria stringEjemplo.</td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">Utilities::Vector3<float> getVector3(std::string name)</a></th>
									<td>Devuelve el Vector3 con el name correspondiente, para el ejemplo anterio seria vector3Ejemplo.</td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">Utilities::Vector4<float> getVector4(std::string name)</a></th>
									<td>Devuelve el vector4 con el name correspondiente, para el ejemplo anterio seria vector4Ejemplo.</td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">bool tryGetInt(std::string name, int& value)</a></th>
									<td>Devuelve true si no falla el name enviado y su valor pasa a ser el de value. </td>
								
								</tr>

								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">bool tryGetFloat(std::string name, float& value)</a></th>
									<td>Devuelve true si no falla el name enviado y su valor pasa a ser el de value. </td>
								
								</tr>
								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">bool tryGetBool(std::string name, bool& value)</a></th>
									<td>Devuelve true si no falla el name enviado y su valor pasa a ser el de value. </td>
								
								</tr>
								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">bool tryGetChar(std::string name, char& value)</a></th>
									<td>Devuelve true si no falla el name enviado y su valor pasa a ser el de value. </td>
								
								</tr>
								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">bool  tryGetString(std::string name, std::string& value)</a></th>
									<td>Devuelve true si no falla el name enviado y su valor pasa a ser el de value. </td>
								
								</tr>
								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">bool tryGetVector3(std::string name, Utilities::Vector3<float>& value)</a></th>
									<td>Devuelve true si no falla el name enviado y su valor pasa a ser el de value. </td>
								
								</tr>
								<tr>
									<th class="theme-bg-light"><a class="theme-link" href="#">bool tryGetVector4(std::string name, Utilities::Vector4<float>& value)</a></th>
									<td>Devuelve true si no falla el name enviado y su valor pasa a ser el de value. </td>
								
								</tr>
							</tbody>
						</table>
					</div><!--//table-responsive-->


					<div class="callout-block callout-block-success">
						<div class="content">
							<h4 class="callout-title">
								<span class="callout-icon-holder me-1">
									<i class="fas fa-thumbs-up"></i>
								</span><!--//icon-holder-->
								Tip
							</h4>
							<p>Se aconseja usar los metodos tryeGet.</p>
						</div><!--//content-->
					</div><!--//callout-block-->

					</section><!--//section-->
					
					<section class="docs-section" id="item-12-2">
						<h2 class="section-heading">Vector2</h2>
						<p>Clase que define un vector de 2 dimensiones. El primer valor corresponde a la variable X y el segundo a la Y.  </p>

						<div class="callout-block callout-block-info">
								
							<div class="content">
									<h4 class="callout-title">
									<span class="callout-icon-holder me-1">
										<i class="fas fa-info-circle"></i>
									</span><!--//icon-holder-->
										Nota
									</h4>
								<p> Las componentes del vector son publicas y existen operadores de comparacion, suma, resta y multiplicación. Además, el vector es un template por lo que puede ser de cualquier tipo. </p>
							</div><!--//content-->
						</div><!--//callout-block-->
						
						<p>Aqui estan todos los metodos definidos en ella.</p>
						
						<div class="table-responsive my-4">
							<table class="table table-bordered">
								<tbody>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Vector2()</a></th>
										<td>Constructora que crea un vector con los valores a 0. </td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Vector2(T prim, T sec)</a></th>
										<td>Constructora que da a x el valor de prim y a y el valor de sec. </td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Vector2(const Vector2& v)</a></th>
										<td>Constructora que copia los valores del vector v al vector.</td>
									
									</tr>
									
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void inverse()</a></th>
										<td>Invierte los valores del vector. </td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void add(T sumX, T sumY)</a></th>
										<td>Suma la cantidad sumX al componente x del vector y la cantidad sumY al componente y del vector.</td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">T magnitude()</a></th>
										<td>Devuelve la magnitud del vector.</td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">T magnitudeSqr()</a></th>
										<td>Devuelve la magnitud al cuadrado del vector.</td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void normalize()</a></th>
										<td>Normaliza el vector.</td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">T scalarProduct(Vector2<T> b)</a></th>
										<td>Devuelve el producto escalar del vector y del enviado como parametro.</td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void lerp(Vector2<T> b, float t)</a></th>
										<td>Devuelve el vector interpolado entre el propio vector y b en funcion de la interpolacion t.  </td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Vector2<T> lerp(Vector2<T> a, Vector2<T> b, float t))</a></th>
										<td>Devuelve el vector interpolado entre a y b en funcion de la interpolacion t.  </td>
									
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">T getDistance(Vector2<T> b) </a></th>
										<td>Devuelve la distancia al valor enviado como parametro. </td>
									
									</tr>
								</tbody>
							</table>
						</div><!--//table-responsive-->
					</section><!--//section-->
					
					<section class="docs-section" id="item-12-3">
						<h2 class="section-heading">Vector3</h2>
						<p>Clase que define un vector de 3 dimensiones. El primer valor corresponde a la variable, el segundo a la Y y el tercero la Z.  </p>

						<div class="callout-block callout-block-info">
								
							<div class="content">
									<h4 class="callout-title">
									<span class="callout-icon-holder me-1">
										<i class="fas fa-info-circle"></i>
									</span><!--//icon-holder-->
										Nota
									</h4>
								<p> Las componentes del vector son publicas y existen operadores de comparacion, suma, resta y multiplicación. Además, el vector es un template por lo que puede ser de cualquier tipo. </p>
							</div><!--//content-->
						</div><!--//callout-block-->
						
						<p>Aqui estan todos los metodos definidos en ella.</p>
						
						<div class="table-responsive my-4">
							<table class="table table-bordered">
								<tbody>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Vector3()</a></th>
										<td>Constructora que crea un vector con los valores a 0. </td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Vector3(T prim, T sec, T ter)</a></th>
										<td>Constructora que da a x el valor de prim, a y el valor de sec y a z el valor de ter. </td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Vector3(const Vector3& v)</a></th>
										<td>Constructora que copia los valores del vector v al vector.</td>
									
									</tr>
									
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void inverse()</a></th>
										<td>Invierte los valores del vector. </td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void add(T sumX, T sumY, T sumZ)</a></th>
										<td>Suma la cantidad sumX al componente x del vector, la cantidad sumY al componente y del vector y la cantidad sumZ a la compoennte z del vector.</td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">T magnitude()</a></th>
										<td>Devuelve la magnitud del vector.</td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">T magnitudeSqr()</a></th>
										<td>Devuelve la amgnitud al cuadrado del vector.</td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void normalize()</a></th>
										<td>Normaliza el vector.</td>
									
									</tr>
									
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Vector3<T> getNormalized()</a></th>
										<td>Devuelve el vector3 normalizado. </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">T scalarProduct(Vector3<T> b)</a></th>
										<td>Devuelve el producto escalar del vector y del enviado como parametro.</td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Vector3<T> lerp(Vector3<T> a, Vector3<T> b, float t)</a></th>
										<td>Devuelve el vector interpolado entre a y b en funcion de la interpolacion t.  </td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Vector3<T> vectorialProduct(Vector3<T> b)</a></th>
										<td>Devuelve el producto vectorial del vector y el enviado como parametro. </td>
									
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">T getDistance(Vector3<T> b) </a></th>
										<td>Devuelve la distancia al valor enviado como parametro. </td>
									
									</tr>
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Vector3<T> rotateX(double degrees)</a></th>
										<td>Devuelve el vector rotado sobre el eje X los grados indicados en el parametro. </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Vector3<T> rotateY(double degrees)</a></th>
										<td>Devuelve el vector rotado sobre el eje Y los grados indicados en el parametro. </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Vector3<T> rotateZ(double degrees)</a></th>
										<td>Devuelve el vector rotado sobre el eje Z los grados indicados en el parametro. </td>
									
									</tr>
								</tbody>
							</table>
						</div><!--//table-responsive-->
					</section><!--//section-->


					<section class="docs-section" id="item-12-4">
						<h2 class="section-heading">Vector4</h2>
						<p>Clase que define un vector de 4 dimensiones. El primer valor corresponde a la variable, el segundo a la Y, el tercero la Z y el 4 a la W.  </p>

						<div class="callout-block callout-block-info">
								
							<div class="content">
									<h4 class="callout-title">
									<span class="callout-icon-holder me-1">
										<i class="fas fa-info-circle"></i>
									</span><!--//icon-holder-->
										Nota
									</h4>
								<p> Las componentes del vector son publicas y existen operadores de comparacion, suma, resta y multiplicación. Además, el vector es un template por lo que puede ser de cualquier tipo. </p>
							</div><!--//content-->
						</div><!--//callout-block-->
						
						<p>Aqui estan todos los metodos definidos en ella.</p>
						
						<div class="table-responsive my-4">
							<table class="table table-bordered">
								<tbody>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Vector4()</a></th>
										<td>Constructora que crea un vector con los valores a 0. </td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Vector3(T prim, T sec, T ter, T cuar)</a></th>
										<td>Constructora que da a x el valor de prim, a y el valor de sec, la z el valor de ter y el valor w a cuar. </td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">Vector4(const Vector4& v)</a></th>
										<td>Constructora que copia los valores del vector v al vector.</td>
									
									</tr>
									
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">void inverse()</a></th>
										<td>Invierte los valores del vector. </td>
									
									</tr>

									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#"> Vector4<T> EulerToQuaternion(Vector3<T> v)</a></th>
										<td>Devuelve el vector4 de pasar el vector a quaternion a partir del <a href="#item-12-3"> vector3</a> </td>
									
									</tr>
								</tbody>
							</table>
						</div><!--//table-responsive-->
					</section><!--//section-->


					<section class="docs-section" id="item-12-5">
						<h2 class="section-heading">Random</h2>
						<p>Clase donde se generan numeros aleatorios. Aqui estan todos los metodos definidos en ella. </p>

						<div class="table-responsive my-4">
							<table class="table table-bordered">
								<tbody>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">float random()</a></th>
										<td>Devuelve un numero aleatorio de tipo float. </td>
									
									</tr>
	
									<tr>
										<th class="theme-bg-light"><a class="theme-link" href="#">int randomBetween(int min, int max)</a></th>
										<td>Devuelve un numero aleatorio de tipo int entre el min y max establecidos.  </td>
									
									</tr>
								</tbody>
							</table>
						</div><!--//table-responsive-->
					</section><!--//section-->
			    </article><!--//docs-article-->

				<article class="docs-article" id="section-13">
				    <header class="docs-header">
					    <h1 class="docs-heading">Window</h1>
					    <section class="docs-intro">
						    <p>Clase que se encarga de gestionar la ventana del juego. </p>

							<p>Aqui estan todas las funcionesn que utiliza para llevarlo acabo.  </p>

							<div class="table-responsive my-4">
								<table class="table table-bordered">
									<tbody>
		
										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">static Window* getInstance()</a></th>
											<td>Devuelve un puntero a la ventana.  </td>
										
										</tr>
		
										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#"> void setMouseState(MouseState value)</a></th>
											<td> Establece si el raton esta libre (FREE), libre pero solo dentro de la pantalla (INSIDE_WINDOW) o quieto en el centro de la ventana(CENTER). </td>
										
										</tr>
		
										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#"> void mouseVisibility(bool value)</a></th>
											<td>Si value es true el raton se vera en la ventana y no se vera en caso contrario. </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#"> void setWindowTitle(std::string )</a></th>
											<td> Cambia el titulo de la ventana al enviado en el string.  </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#"> void setFullScreen(bool screenmode)</a></th>
											<td>Si screenmode es true la pantalla se vera en pantalla completa y en forma de ventana en caso contrario.  </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#"> void setWindowSize(int x, int y)</a></th>
											<td> Establece el tamaño de la ventana, con anchura x y tamaño y. Tiene una variante donde se le puede enviar un vector2 en vez de 2 int. </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#"> std::string getWindowTitle()</a></th>
											<td> Devuelve el nombre de la ventana. </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#"> MouseState getMouseState()</a></th>
											<td> Devuelve el estado del raton. </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#"> bool isFullScreen(</a></th>
											<td> Devuelve true si es pantalla completa, false en caso contrario </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#"> bool isMouseVisible()</a></th>
											<td> Devuelve true si se ve el raton, false en caso contrario. </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#"> void repositionWindow(Utilities::Vector2<int> pos)</a></th>
											<td> Cambia el tamaño de la ventana en funcion de pos. Tiene una variante donde se le pueden enviar 2 parametros int en vez de un vector2.  </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#"> void setWindowIcon(std::string iconPath)</a></th>
											<td> Establece de icono de ventana el que tiene de ruta iconPath. </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#"> void lockMouse()</a></th>
											<td> Bloquea el movimiento del raton.  </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#"> void freeMouse()</a></th>
											<td> Desbloquea el movimiento del raton.  </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#"> Utilities::Vector2<int> getWindowSize()</a></th>
											<td> Devuelve en un vector2 el tamaño de la ventana.  </td>
										
										</tr>
									</tbody>
								</table>
							</div><!--//table-responsive-->

						</section><!--//docs-intro-->




				    </header>
				    
			    </article><!--//docs-article-->

				<article class="docs-article" id="section-14">
				    <header class="docs-header">
					    <h1 class="docs-heading">Importación de archivos</h1>
					    <section class="docs-intro">
						    <p>Todos los archivos del juego se tienen que encontrar en una carpeta del juego llamada resources, aqui cada tipo de archivos tiene su espacio. </p>


							<div class="table-responsive my-4">
								<table class="table table-bordered">
									<tbody>
		
										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">Fuentes</a></th>
											<td>Se incluyen en la carpeta fonts. Acepta extensiones de tipo .ttf y .fontdef </td>
										
										</tr>
		
										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">Audios</a></th>
											<td>Se incluyen en la carpeta Sounds. Acepta extensiones de tipo .mp3 y .wav </td>
										
										</tr>
		
										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#"> Materiales</a></th>
											<td>Se incluyen en la carpeta materials, dentro de esta estan los .material. </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">Texturas</a></th>
											<td> Se incluyen en la carpeta textures que esta dentro de la de materials. Acepta extensiones de tipo .png y .jpg </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">Modelos</a></th>
											<td>Se encuentran en la carpeta models </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">Particulas</a></th>
											<td>Se incluyen en la carpeta particles</td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">LUA</a></th>
											<td>Se incluye en la carpeta Scripts </td>
										
										</tr>

										<tr>
											<th class="theme-bg-light"><a class="theme-link" href="#">Compositors</a></th>
											<td>Se incluyen en la carpeta compositors.  </td>
										
										</tr>
									</tbody>
								</table>
							</div><!--//table-responsive-->

						</section><!--//docs-intro-->
				    </header>
			    </article><!--//docs-article-->

			    <footer class="footer">
				    <div class="container text-center py-5">
				        <small class="copyright">Copyright &copy; <a href="https://github.com/Triturados" target="_blank">Triturados</a></small>
				        <ul class="social-list list-unstyled pt-4 mb-0">
						    <li class="list-inline-item"><a href="https://github.com/Triturados/Motor"><i class="fab fa-github fa-fw"></i></a></li> 
				            <!-- <li class="list-inline-item"><a href="#"><i class="fab fa-twitter fa-fw"></i></a></li>
				            <li class="list-inline-item"><a href="#"><i class="fab fa-slack fa-fw"></i></a></li>
				            <li class="list-inline-item"><a href="#"><i class="fab fa-product-hunt fa-fw"></i></a></li>
				            <li class="list-inline-item"><a href="#"><i class="fab fa-facebook-f fa-fw"></i></a></li>
				            <li class="list-inline-item"><a href="#"><i class="fab fa-instagram fa-fw"></i></a></li> -->
				        </ul><!--//social-list-->
				    </div>
			    </footer>
		    </div> 
	    </div>
    </div><!--//docs-wrapper-->
   
       
    <!-- Javascript -->          
    <script src="assets/plugins/popper.min.js"></script>
    <script src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>  
    
    
    <!-- Page Specific JS -->
    <script src="assets/plugins/smoothscroll.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
    <script src="assets/js/highlight-custom.js"></script> 
    <script src="assets/plugins/simplelightbox/simple-lightbox.min.js"></script>      
    <script src="assets/plugins/gumshoe/gumshoe.polyfills.min.js"></script> 
    <script src="assets/js/docs.js"></script> 

</body>
</html> 

